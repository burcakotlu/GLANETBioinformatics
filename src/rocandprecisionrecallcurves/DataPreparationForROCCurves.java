/**
 * 
 */
package rocandprecisionrecallcurves;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import auxiliary.FileOperations;

import common.Commons;

import enumtypes.AssociationMeasureType;
import enumtypes.DataDrivenExperimentCellLineType;
import enumtypes.DataDrivenExperimentDnaseOverlapExclusionType;
import enumtypes.DataDrivenExperimentElementNameType;
import enumtypes.DataDrivenExperimentGeneType;
import enumtypes.DataDrivenExperimentTPMType;
import enumtypes.GenerateRandomDataMode;
import enumtypes.IsochoreFamilyMode;
import enumtypes.ToolType;
import gnu.trove.iterator.TObjectIntIterator;
import gnu.trove.map.TObjectFloatMap;
import gnu.trove.map.TObjectIntMap;
import gnu.trove.map.hash.TObjectFloatHashMap;
import gnu.trove.map.hash.TObjectIntHashMap;

/**
 * @author Burçak Otlu
 * @date Feb 22, 2017
 * @project GLANETBioinformatics 
 * 
 * This file creates data for plotting ROC Curves.
 * Same data helps us to plot precision and recall curves.
 * 
 * In the output file, there are 4 columns
 * D	D.str	M	GLANETParameter
 * D holds 0 for Enriched in D.str
 * D holds 1 for NotEnriched in D.str
 * M holds the pValue
 * GLANETParameter holds the parameters GLANET or GAT run with.
 * 
 * 
 * This class requires directory where the runs will be present
 * And number of runs at most 1000
 * And takes 7 strings and 7 integers, integer can be 1 or 0, in the order of one string one integer, ...
 * 
 * If string can be converted to a certain enum it is directly used in Output fileName (e.g.: CompletelyDiscard)
 * If string can not be converted to a certain enum but if it is followed by a subsequent 1, its shortcut string name is used in Output fileName (e.g.: DiscardType)
 * 
 * GLANETParameter column is formed by the subsequent 1s and 0s, if it is 1, it is written in its GLANETParameter column, 
 * else it is not written in its GLANETParameter column, it is pooled.
 * 
 * Please notice that data generated by this class is being used by the precision and recall curves.
 * 
 * You can use the run examples in treepad, burcak mind.
 *
 * For GLANET: 
 * java -jar "/truba/home/botlu/GLANET/JarFiles/PrepareDataForROCCurves.jar" "GLANET" "/truba/home/botlu/GLANET/" 1000 "Cell" 0 "ExpressingGenes" 1 "NoDiscard" 0 "Top" 0 "Existence of Overlap" 1 "Without Isochore Family Pools" 1  "genRandomData" 1
 *
 * For GAT:
 * java -jar "/home/burcakotlu/JarFiles/PrepareDataForROCCurves.jar" "GAT" "/home/burcakotlu/DDE" 1000 "Cell" 0 "ExpressingGenes" 1 "Discard" 0 "Top" 0 "Existence of Overlap" 1 "Without Isochore Family Pools" 1  "genRandomData" 1
 */
public class DataPreparationForROCCurves {
	
	
	public static Float getEmpiricalPValue(String strLine){
		
		int indexofFirstTab;
		int indexofSecondTab;
		int indexofThirdTab;
		int indexofFourthTab;
		int indexofFifthTab;
		int indexofSixthTab;
		int indexofSeventhTab;
		int indexofEigthTab;
		int indexofNinethTab;
		int indexofTenthTab;
		
		indexofFirstTab 	= strLine.indexOf('\t');
		indexofSecondTab 	= (indexofFirstTab > 0)?strLine.indexOf('\t', indexofFirstTab + 1):-1;
		indexofThirdTab 	= (indexofSecondTab > 0)?strLine.indexOf('\t', indexofSecondTab + 1):-1;
		indexofFourthTab 	= (indexofThirdTab > 0)?strLine.indexOf('\t', indexofThirdTab + 1):-1;
		indexofFifthTab 	= (indexofFourthTab > 0)?strLine.indexOf('\t', indexofFourthTab + 1):-1;
		indexofSixthTab 	= (indexofFifthTab > 0)?strLine.indexOf('\t', indexofFifthTab + 1):-1;
		indexofSeventhTab 	= (indexofSixthTab > 0)?strLine.indexOf('\t', indexofSixthTab + 1):-1;
		indexofEigthTab 	= (indexofSeventhTab > 0)?strLine.indexOf('\t', indexofSeventhTab + 1):-1;
		indexofNinethTab 	= (indexofEigthTab > 0)?strLine.indexOf('\t', indexofEigthTab + 1):-1;
		indexofTenthTab 	= (indexofNinethTab > 0)?strLine.indexOf('\t', indexofNinethTab + 1):-1;
		
		//Between indexofNinethTab and indexofTenthTab
		Float empiricalPValue = Float.parseFloat(strLine.substring(indexofNinethTab+1, indexofTenthTab));
		
		return empiricalPValue;
	}
	
	
	//For each output file 
	public static void readResultFile(
			String resultFileName, 
			List<DataDrivenExperimentElementNameType> activatorElementList,
			List<DataDrivenExperimentElementNameType> repressorElementList,
			TObjectFloatMap<DataDrivenExperimentElementNameType> activator2EmpPValueMap,
			TObjectFloatMap<DataDrivenExperimentElementNameType> repressor2EmpPValueMap){
		
		
		FileReader fileReader = null;
		BufferedReader bufferedReader = null;
		String strLine = null;
		
		int indexofFirstUnderscore;
		String elementName = null;
		Float empiricalPValue = null;
		
		DataDrivenExperimentElementNameType element = null;
		
		
		try {
			fileReader = FileOperations.createFileReader(resultFileName);
			bufferedReader = new BufferedReader(fileReader);
					
			
			while((strLine = bufferedReader.readLine())!=null){
				
				if (!strLine.startsWith("#")){
					
					indexofFirstUnderscore = strLine.indexOf('_');
					elementName= strLine.substring(0,indexofFirstUnderscore);
					
					element = DataDrivenExperimentElementNameType.convertStringtoEnum(elementName);
					
					if (activatorElementList.contains(element)){
						
						//gets its empirical p value
						empiricalPValue = getEmpiricalPValue(strLine);
						activator2EmpPValueMap.put(element,empiricalPValue);
						
												
					}else if (repressorElementList.contains(element)){
						
						empiricalPValue = getEmpiricalPValue(strLine);
						repressor2EmpPValueMap.put(element,empiricalPValue);
						
					}				
					
				}//End of IF not an comment line
				
			}//End of while
			
			//Close
			bufferedReader.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}	
		
	}
	
	
	//For collecting GAT ROC Curve Data
	public static void processLine(
			String strLine,
			String tag,
			DataDrivenExperimentGeneType geneType,
			List<DataDrivenExperimentElementNameType> activatorElementList, 
			List<DataDrivenExperimentElementNameType> repressorElementList,
			BufferedWriter bufferedWriter) throws IOException{
		
		String cellLineNameElementName = null;
		String elementName = null;
		DataDrivenExperimentElementNameType elementNameType = null;
	
		float empiricalPValue;
		float ln2Fold;
		
		int indexofUnderscore;

		int indexofFirstTab;
		int indexofSecondTab;
		int indexofThirdTab;
		int indexofFourthTab;
		int indexofFifthTab;
		int indexofSixthTab;
		int indexofSeventhTab;
		int indexofEigthTab;
		int indexofNinethTab;
		int indexofTenthTab;
		
		indexofFirstTab = strLine.indexOf( '\t');
		indexofSecondTab = ( indexofFirstTab > 0)?strLine.indexOf( '\t', indexofFirstTab + 1):-1;
		indexofThirdTab = ( indexofSecondTab > 0)?strLine.indexOf( '\t', indexofSecondTab + 1):-1;
		indexofFourthTab = ( indexofThirdTab > 0)?strLine.indexOf( '\t', indexofThirdTab + 1):-1;
		indexofFifthTab = ( indexofFourthTab > 0)?strLine.indexOf( '\t', indexofFourthTab + 1):-1;
		indexofSixthTab = ( indexofFifthTab > 0)?strLine.indexOf( '\t', indexofFifthTab + 1):-1;
		indexofSeventhTab = ( indexofSixthTab > 0)?strLine.indexOf( '\t', indexofSixthTab + 1):-1;
		indexofEigthTab = ( indexofSeventhTab > 0)?strLine.indexOf( '\t', indexofSeventhTab + 1):-1;
		indexofNinethTab = ( indexofEigthTab > 0)?strLine.indexOf( '\t', indexofEigthTab + 1):-1;
		indexofTenthTab = ( indexofNinethTab > 0)?strLine.indexOf( '\t', indexofNinethTab + 1):-1;
		
		if(indexofFirstTab!=-1 && indexofSecondTab!=-1 && indexofNinethTab!=-1 && indexofTenthTab!=-1){
			
			cellLineNameElementName = strLine.substring(indexofFirstTab + 1, indexofSecondTab);
			indexofUnderscore = cellLineNameElementName.indexOf("_");
			elementName = cellLineNameElementName.substring(indexofUnderscore+1);
			
			elementNameType = DataDrivenExperimentElementNameType.convertStringtoEnum(elementName);			
				
			//In case of enrichment ln2Fold must be positive and pValue must be less than significance level
			//In case of depletion ln2Fold must be negative and pValue must be less than significance level
					
			//ln2fold is between 8thTab and 9thTab
			ln2Fold = Float.parseFloat(strLine.substring(indexofEigthTab + 1, indexofNinethTab));
			
			//pValue is between 9thTab and 10thTab
			//pValue is both used for enrichment and depletion
			empiricalPValue = Float.parseFloat(strLine.substring(indexofNinethTab + 1, indexofTenthTab));
			
			
			//TODO Shall I consider ln2Fold?
			//Decision: Yes
			//If ln2fold is positive take empiricalPValue as it is
			//If ln2fold is negative take 1-empiricalPValue
			if(ln2Fold<0){
				empiricalPValue = 1-empiricalPValue;
			}
			
			//Update and Accumulate
			if (activatorElementList.contains(elementNameType)){
				
				switch (geneType) {
				
					case  EXPRESSING_PROTEINCODING_GENES:
						bufferedWriter.write("0" + "\t" + "Enriched" + "\t" + empiricalPValue + "\t" + tag + System.getProperty("line.separator"));																				
						break;
					
						
					case NONEXPRESSING_PROTEINCODING_GENES:
						bufferedWriter.write("1" + "\t" + "NotEnriched" + "\t" + empiricalPValue + "\t" + tag + System.getProperty("line.separator"));													
						break;
	
					default:
						break;
				}//End of switch
				
			}else if (repressorElementList.contains(elementNameType)){
				
				switch (geneType) {
				
					case  EXPRESSING_PROTEINCODING_GENES:					
						bufferedWriter.write("1" + "\t" + "NotEnriched" + "\t" + empiricalPValue + "\t" + tag + System.getProperty("line.separator"));						
						break;
						
					case NONEXPRESSING_PROTEINCODING_GENES:
						bufferedWriter.write("0" + "\t" + "Enriched" + "\t" +empiricalPValue + "\t" + tag + System.getProperty("line.separator"));						
						break;
	
					default:
						break;
				}//End of switch
				
			}
				
			
		}//End of IF valid strLine control
		
	}

	
	//For collecting GAT ROC Curve Data
	public static void prepareTabDelimitedDataFileForGATROCCurve(
			String mainDirectory,
			String runDirectory,
			int numberofRuns, 
			DataDrivenExperimentGeneType geneType, 
			String tag, 
			List<DataDrivenExperimentElementNameType> activatorElementList, 
			List<DataDrivenExperimentElementNameType> repressorElementList,
			BufferedWriter bufferedWriter){
		
		String strLine = null;
		File gatTSVFile = null;
		
		FileReader gatTSVFileReader = null;
		BufferedReader gatTSVBufferedReader = null;
			
		try{

			// For each run
			for(int i = 0; i <numberofRuns; i++){
								
				gatTSVFile = new File(mainDirectory + System.getProperty("file.separator")  + runDirectory + i + Commons.TSV);
									
				if (gatTSVFile.exists() && gatTSVFile.isFile()){
					
					//check it
					gatTSVFileReader = FileOperations.createFileReader(gatTSVFile.getAbsolutePath());
					gatTSVBufferedReader = new BufferedReader(gatTSVFileReader);
					
					//example lines
//					track	annotation	observed	expected	CI95low	CI95high	stddev	fold	l2fold	pvalue	qvalue	track_nsegments	track_size	track_density	annotation_nsegments	annotation_size	annotation_density	overlap_nsegments	overlap_size	overlap_density	percent_overlap_nsegments_track	percent_overlap_size_track	percent_overlap_nsegments_annotation	percent_overlap_size_annotation
//					merged	GM12878_H3K4ME3	5042	10527.8922	6860	14481	2316.527	0.479	-1.062	6.10E-03	1.22E-02	500	276698	8.94E-03	27920	101790620	3.29E+00	24	5042	1.63E-04	4.8	1.8222	0.086	0.005
//					merged	GM12878_H3K4ME1	8039	15521.7919	11019	20190	2779.2138	0.5179	-0.9491	1.40E-03	5.60E-03	500	276698	8.94E-03	41605	156124633	5.04E+00	24	8039	2.60E-04	4.8	2.9053	0.0577	0.0051
//					merged	GM12878_H3K4ME2	9057	13720.137	9604	18156	2602.1074	0.6601	-0.5991	2.96E-02	3.95E-02	500	276698	8.94E-03	45162	134962712	4.36E+00	35	9057	2.93E-04	7	3.2732	0.0775	0.0067
//					merged	GM12878_H2AZ	6764	8783.6121	5543	12379	2094.3924	0.7701	-0.3769	1.71E-01	1.71E-01	500	276698	8.94E-03	40693	89430210	2.89E+00	27	6764	2.19E-04	5.4	2.4445	0.0664	0.0076

					// Skip HeaderLine
					strLine = gatTSVBufferedReader.readLine();
										
					// Read gatTSVFile
					while( ( strLine = gatTSVBufferedReader.readLine()) != null){
						
						processLine(strLine,tag,geneType,activatorElementList, repressorElementList, bufferedWriter);
						
					}// End of WHILE
					
					
					// Close
					gatTSVBufferedReader.close();
					
				}//End of IF gatTSVFile exists
				
				else{
					//Write down this file does not exists
					//Exit from loop
					System.out.println("There is no file for this run: " + i + "\t" +  gatTSVFile.getAbsolutePath());
				
				}
						
			}// End of FOR each run
			
			
		}catch( IOException e){
			e.printStackTrace();
		}
		
	}
	
	
	public static void prepareTabDelimitedDataFileForGLANETROCCurveAndPRCurve(
			String mainDirectory, 
			String runDirectory, 
			int numberofRuns, 
			DataDrivenExperimentGeneType geneType,
			String tag,
			List<DataDrivenExperimentElementNameType> activatorElementList,
			List<DataDrivenExperimentElementNameType> repressorElementList,
			BufferedWriter bufferedWriter_ROCCurve,
			TObjectIntMap<DataDrivenExperimentElementNameType> element2NumberofMissingPValuesMap){
		
		String eachRunDirectory = null;
		File histoneDirectory = null;
		File tfDirectory = null;
		
		String resultFileName = null;	
		
		boolean thereIsSuchAFile = false;
		
		int numberofFilesReadforHistone = 0;
		int numberofFilesReadforTF = 0;
			
		DataDrivenExperimentElementNameType element = null;
		float pValue = 0f;
		
		//For each run
		for(int i=0; i< numberofRuns; i++){
			
			//Create Instances
			TObjectFloatMap<DataDrivenExperimentElementNameType> activator2EmpPValueMap  =  new TObjectFloatHashMap<DataDrivenExperimentElementNameType>();
			TObjectFloatMap<DataDrivenExperimentElementNameType> repressor2EmpPValueMap  =  new TObjectFloatHashMap<DataDrivenExperimentElementNameType>();
					
			eachRunDirectory = mainDirectory + runDirectory + i + System.getProperty("file.separator") + Commons.ENRICHMENT + System.getProperty("file.separator");
			
			histoneDirectory  = new File(eachRunDirectory + Commons.HISTONE + System.getProperty("file.separator"));
			tfDirectory  = new File(eachRunDirectory + Commons.TF + System.getProperty("file.separator"));
			
			//Histone
			if(histoneDirectory.exists() && histoneDirectory.isDirectory()){
				
				//Initialize
				thereIsSuchAFile = false;
				
				for(File eachHistoneFile : histoneDirectory.listFiles()){
					
					//Read cellLineFiltered file
					if(!eachHistoneFile.isDirectory() && 
							(eachHistoneFile.getAbsolutePath().contains("_2017_"))){
						
						//formerly it was  contains("Run" + i + ".txt")
						
						thereIsSuchAFile = true;
						numberofFilesReadforHistone++;

						resultFileName = eachHistoneFile.getAbsolutePath();								
						readResultFile(resultFileName,activatorElementList,repressorElementList,activator2EmpPValueMap,repressor2EmpPValueMap);						
						break;

					}// End of IF EnrichmentFile under EnrichmentDirectory
					
				}//End of for each file in histone Directory
				
				//Check
				if(!thereIsSuchAFile){
					System.out.println("There is no result file for directory " + histoneDirectory);
				}
				
				
			}//End of IF histone directory exists
			
			
			//TF
			if(tfDirectory.exists() && tfDirectory.isDirectory()){
				
				//initialize
				thereIsSuchAFile = false;
				
				for(File eachTFFile : tfDirectory.listFiles()){
					
					//read cellLineFiltered file
					if(!eachTFFile.isDirectory() && 
							(eachTFFile.getAbsolutePath().contains("_2017_"))){
						
						//formerly it was  contains("Run" + i + ".txt")
						
						thereIsSuchAFile = true;
						numberofFilesReadforTF++;

						resultFileName = eachTFFile.getAbsolutePath();								
						readResultFile(resultFileName,activatorElementList,repressorElementList,activator2EmpPValueMap,repressor2EmpPValueMap);						
						break;

					}// End of IF EnrichmentFile under EnrichmentDirectory
					
				}//End of for each file in histone Directory
				
				//Check
				if(!thereIsSuchAFile){
					System.out.println("There is no result file for directory " + tfDirectory);
				}
				
			}//End of IF TF directory exists
			
			//For all missing activator elements put a pValue of 1.
			for(Iterator<DataDrivenExperimentElementNameType> itr =activatorElementList.iterator();itr.hasNext();){
				
				element = itr.next();
				
				if (!activator2EmpPValueMap.containsKey(element)){
					activator2EmpPValueMap.put(element,1.0f);
					
					//For information
					if (!element2NumberofMissingPValuesMap.containsKey(element)){
						element2NumberofMissingPValuesMap.put(element, 1);
					}else{
						element2NumberofMissingPValuesMap.put(element, element2NumberofMissingPValuesMap.get(element)+1);
					}
				}
				
			}//End of FOR
			
			
			//For all missing repressor elements put a pValue of 1.
			for(Iterator<DataDrivenExperimentElementNameType> itr =repressorElementList.iterator();itr.hasNext();){
				
				element = itr.next();
				
				if (!repressor2EmpPValueMap.containsKey(element)){
					repressor2EmpPValueMap.put(element,1.0f);
					
					//For information
					if (!element2NumberofMissingPValuesMap.containsKey(element)){
						element2NumberofMissingPValuesMap.put(element, 1);
					}else{
						element2NumberofMissingPValuesMap.put(element, element2NumberofMissingPValuesMap.get(element)+1);
					}
				}
				
			}//End of FOR
			
			
			try {

				//write to a file
				//elementName tab empiricalNValue
				//with elementName in ascending order
				//try in laptop then move the jar to levreks
				
				//Write in a sorted way
				for(int j=0; j<activatorElementList.size();j++){
					
					element = activatorElementList.get(j);
					
					pValue = activator2EmpPValueMap.get(element);
					
					if (geneType.isExpressingProteinCodingGenes()){
						bufferedWriter_ROCCurve.write("0" + "\t" + "Enriched" + "\t" + pValue + "\t" + tag + System.getProperty("line.separator"));						
												
					}else {
						bufferedWriter_ROCCurve.write("1" + "\t" + "NotEnriched" + "\t" + pValue + "\t" + tag + System.getProperty("line.separator"));	
					}
										
				}
				
				for(int j=0; j<repressorElementList.size();j++){
					
					element = repressorElementList.get(j);
					
					pValue = repressor2EmpPValueMap.get(element);
					
					if (geneType.isExpressingProteinCodingGenes()){
						bufferedWriter_ROCCurve.write("1" + "\t" + "NotEnriched" + "\t" +  pValue + "\t" + tag +  System.getProperty("line.separator"));		
					}else {
						bufferedWriter_ROCCurve.write("0" + "\t" + "Enriched" + "\t" + pValue + "\t" + tag + System.getProperty("line.separator"));	
					}
				}
				
				
			
			} catch (IOException e) {
				e.printStackTrace();
			}
			
			//Free space
			activator2EmpPValueMap = null;
			repressor2EmpPValueMap = null;

		}//End of For each run number
		
		//Check
		if (numberofFilesReadforHistone!=1000){
			System.out.println("numberofFilesReadforHistone: " + numberofFilesReadforHistone);
		}
		
		//Check
		if (numberofFilesReadforTF!=1000){
			System.out.println("numberofFilesReadforTF: " + numberofFilesReadforTF);
		}
				
	}

	
	public static void fillWithDataDrivenExperimentElementNameTypesIncludingAmbigiousElements(
			DataDrivenExperimentCellLineType cellLineType,
			List<DataDrivenExperimentElementNameType> activatorElementList,
			List<DataDrivenExperimentElementNameType> repressorElementList){
		
		
		//Activators
		activatorElementList.add(DataDrivenExperimentElementNameType.POL2);
		activatorElementList.add(DataDrivenExperimentElementNameType.H2AZ);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K27AC);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K4ME2);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K4ME3);		
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K79ME2);		
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K9AC);		
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K4ME1); 		// <--- Ambigious	
		
		//Let's remove this ambigious
		activatorElementList.add(DataDrivenExperimentElementNameType.H4K20ME1); 	// <--- Ambigious
		
		//We have to consider H3K36ME3 otherwise AUC increases enormously
	    activatorElementList.add(DataDrivenExperimentElementNameType.H3K36ME3); 	// <--- Ambigious		
						
		//Repressors 
		repressorElementList.add(DataDrivenExperimentElementNameType.H3K27ME3);		
		
		//We have to consider H3K9me3 otherwise woGCM has the highest AUC in Expressed scenario
		repressorElementList.add(DataDrivenExperimentElementNameType.H3K9ME3); 		// <--- Ambigious		
		
		
		switch (cellLineType){
		
			case K562:
				//Activators
				activatorElementList.add(DataDrivenExperimentElementNameType.H3K9ACB);		
				break;
				
			default:
				break;
		
		}//End  of switch
							
		
	}
	
	//No ambigious element considered
	public static void fillWithDataDrivenExperimentElementNameTypes(
			List<DataDrivenExperimentElementNameType> activatorElementList,
			List<DataDrivenExperimentElementNameType> repressorElementList){
		
		//Activators
		activatorElementList.add(DataDrivenExperimentElementNameType.POL2);
		activatorElementList.add(DataDrivenExperimentElementNameType.H2AZ);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K27AC);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K4ME2);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K4ME3);		
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K79ME2);		
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K9AC);
		activatorElementList.add(DataDrivenExperimentElementNameType.H3K9ACB);		
			
		
		//Repressors 
		repressorElementList.add(DataDrivenExperimentElementNameType.H3K27ME3);
		
	}
	
	public static String createTag(
			ToolType toolType,
			DataDrivenExperimentCellLineType cellLine,int cellLineTag,
			DataDrivenExperimentGeneType geneType,int geneTypeTag,
			DataDrivenExperimentTPMType tpmType,int tpmTypeTag,
			DataDrivenExperimentDnaseOverlapExclusionType exclusionType,int exclusionTypeTag,
			AssociationMeasureType measureType,int measureTypeTag,
			IsochoreFamilyMode isochoreFamilyMode,int isochoreFamilyModeTag,
			GenerateRandomDataMode generateRandomDataMode,int generateRandomDataModeTag){
		
		String tag = "";
		
		String gatSpecial="";
		
		if (toolType.isGAT()){
			tag = tag + toolType.convertEnumtoString();
		}
		
		if (cellLineTag==1){
			if (tag.isEmpty()){
				tag = tag + cellLine;
			}else{
				tag = tag + "_" + cellLine;
			}
			
		}
		
		if (geneTypeTag==1){
			
			if (tag.isEmpty()){
				tag = tag + geneType.convertEnumtoShortString();	
			}else{
				tag = tag +  "_" + geneType.convertEnumtoShortString();	
			}
		}
		
		if (tpmTypeTag==1){
			
			if (tag.isEmpty()){
				tag = tag  + tpmType.convertEnumtoString();	
			}else{
				tag = tag  + "_" +  tpmType.convertEnumtoString();	
			}
			
					
		}

		
		if (exclusionTypeTag==1){
			
			if (tag.isEmpty()){
				tag = tag + exclusionType.convertEnumtoString();
			}else {
				tag = tag  + "_" + exclusionType.convertEnumtoString();
			}
			
		}
		
		if (measureTypeTag==1){
			
			if (tag.isEmpty()){
				tag = tag + measureType.convertEnumtoShortString();
			}else{
				tag = tag  + "_" + measureType.convertEnumtoShortString();
			}
			
		}

		if (isochoreFamilyModeTag==1){		
			
			if (tag.isEmpty()){
				tag = tag + isochoreFamilyMode.convertEnumtoShortString();
			}else{
				tag = tag  + "_" + isochoreFamilyMode.convertEnumtoShortString();
			}
						
		}
		
		if (generateRandomDataModeTag==1){
			
			//GAT
			if (toolType.isGAT()){
				
				if (generateRandomDataMode.isGenerateRandomDataModeWithGC()){
					gatSpecial = "wIF_woGCM";
				}
				if (generateRandomDataMode.isGenerateRandomDataModeWithoutMapabilityandGc()){
					gatSpecial = "woIF_woGCM";
				}
				
				if (tag.isEmpty()){
					tag = tag + gatSpecial;
				}else{
					tag = tag + "_" + gatSpecial;
				}
			}
			//GLANET
			else if(toolType.isGLANET()){
				
				if (tag.isEmpty()){
					tag = tag + generateRandomDataMode.convertEnumtoShortString();
				}else{
					tag = tag + "_" + generateRandomDataMode.convertEnumtoShortString();
				}
			}
			
			
			
		}
	
		return tag;
		
	}
	
	
	//Write Information
	public static void writeInformation(TObjectIntMap<DataDrivenExperimentElementNameType> element2NumberofMissingPValuesMap,BufferedWriter bufferedWriter) throws IOException{
		
		bufferedWriter.write( System.getProperty("line.separator") + "Element" + "\t" + "NumberofMiss" + System.getProperty("line.separator"));			

		for(TObjectIntIterator<DataDrivenExperimentElementNameType> itr = element2NumberofMissingPValuesMap.iterator();itr.hasNext();){
			itr.advance();			
			bufferedWriter.write(itr.key() + "\t" + itr.value() + System.getProperty("line.separator"));			
		}//End of FOR
	}

	
	public static void prepareDataFileForROCCurves(
			ToolType toolType,
			String mainDirectory,
			int numberofRuns,
			DataDrivenExperimentCellLineType cellLine,
			int cellLineTag,
			DataDrivenExperimentGeneType geneType,
			int geneTypeTag,
			DataDrivenExperimentDnaseOverlapExclusionType exclusionType,
			int exclusionTypeTag,
			DataDrivenExperimentTPMType tpmType,
			int tpmTypeTag,
			AssociationMeasureType measureType,
			int measureTypeTag,
			IsochoreFamilyMode  isochoreFamilyMode,
			int isochoreFamilyModeTag,
			GenerateRandomDataMode generateRandomDataMode,
			int generateRandomDataModeTag){
		
		//For information
		TObjectIntMap<DataDrivenExperimentElementNameType> element2NumberofMissingPValuesMap =  new TObjectIntHashMap<DataDrivenExperimentElementNameType>();
		
		FileWriter fileWriter_ROCCurve = null;
		BufferedWriter bufferedWriter_ROCCurve = null;
		
		
		
		String tag = "";
		String distinguisingFileName = "";
		
		//Decision: We have to consider ambiguous elements otherwise ROC curves completely overlaps
		/*******************CONSIDER AMBIGIOUS ELEMENTS****************************************/
		//Fill considered element Names
		List<DataDrivenExperimentElementNameType> activatorElementList = new ArrayList<DataDrivenExperimentElementNameType>();
		List<DataDrivenExperimentElementNameType> repressorElementList = new ArrayList<DataDrivenExperimentElementNameType>();
		/**************************************************************************************/

		//Just for testing purposes
//		/*******************DO NOT CONSIDER AMBIGIOUS ELEMENTS*********************************/
//		//Fill considered element Names
//		List<DataDrivenExperimentElementNameType> activatorElementList = new ArrayList<DataDrivenExperimentElementNameType>();
//		List<DataDrivenExperimentElementNameType> repressorElementList = new ArrayList<DataDrivenExperimentElementNameType>();
//		fillWithDataDrivenExperimentElementNameTypes(activatorElementList,repressorElementList);
//		/**************************************************************************************/

		String runDirectory = null;
		
		/**************************************************************************************/
		//Set 1 considered cellLines
		List<DataDrivenExperimentCellLineType> cellLineList= new ArrayList<DataDrivenExperimentCellLineType>();
		if (cellLine!=null){
			cellLineList.add(cellLine);		
			distinguisingFileName = distinguisingFileName + cellLine.convertEnumtoString();
		}else{
			//pool for them
			cellLineList.add(DataDrivenExperimentCellLineType.GM12878);
			cellLineList.add(DataDrivenExperimentCellLineType.K562);
			
			if(cellLineTag==1){
				distinguisingFileName = distinguisingFileName + "Cell";
			}
		}		
		/**************************************************************************************/
		
		/**************************************************************************************/
		//Set 2 considered geneTypes
		List<DataDrivenExperimentGeneType> geneTypeList= new ArrayList<DataDrivenExperimentGeneType>();
		if (geneType!=null){
			geneTypeList.add(geneType);	
			distinguisingFileName = distinguisingFileName +  "_" + geneType.convertEnumtoShortString() ;

		}else{
			//pool for them
			geneTypeList.add(DataDrivenExperimentGeneType.NONEXPRESSING_PROTEINCODING_GENES);
			geneTypeList.add(DataDrivenExperimentGeneType.EXPRESSING_PROTEINCODING_GENES);
			
			if (geneTypeTag==1){
				distinguisingFileName = distinguisingFileName + "_" + "GeneType";
			}
		}
		/**************************************************************************************/
		

		/**************************************************************************************/
		//Set 3 considered dnase exclusion Types
		List<DataDrivenExperimentDnaseOverlapExclusionType> NE_DnaseExclusionTypeList= new ArrayList<DataDrivenExperimentDnaseOverlapExclusionType>();
		List<DataDrivenExperimentDnaseOverlapExclusionType> E_DnaseExclusionTypeList= new ArrayList<DataDrivenExperimentDnaseOverlapExclusionType>();
		List<DataDrivenExperimentDnaseOverlapExclusionType> dnaseExclusionTypeList= new ArrayList<DataDrivenExperimentDnaseOverlapExclusionType>();
		
		if (exclusionType!=null){
			
			if (geneTypeList.size()==1 && geneTypeList.contains(DataDrivenExperimentGeneType.NONEXPRESSING_PROTEINCODING_GENES)){
				NE_DnaseExclusionTypeList.add(exclusionType);				
			}else if (geneTypeList.size()==1 && geneTypeList.contains(DataDrivenExperimentGeneType.EXPRESSING_PROTEINCODING_GENES)){
				E_DnaseExclusionTypeList.add(exclusionType);				
			}
			
			distinguisingFileName = distinguisingFileName + "_" + exclusionType.convertEnumtoString() ;

						
		}else{
			//pool for them
			NE_DnaseExclusionTypeList.add(DataDrivenExperimentDnaseOverlapExclusionType.COMPLETELY_DISCARD_INTERVAL);
			NE_DnaseExclusionTypeList.add(DataDrivenExperimentDnaseOverlapExclusionType.PARTIALLY_DISCARD_INTERVAL_TAKE_THE_LONGEST_REMAINING_INTERVAL);
			
			E_DnaseExclusionTypeList.add(DataDrivenExperimentDnaseOverlapExclusionType.NO_DISCARD);
			
			if (exclusionTypeTag==1){
				distinguisingFileName = distinguisingFileName +  "_" + "DiscardType";
			}
		}
		/**************************************************************************************/

	
		/**************************************************************************************/
		//Set 4 considered tpmType
		List<DataDrivenExperimentTPMType> NE_tpmTypeList= new ArrayList<DataDrivenExperimentTPMType>();
		List<DataDrivenExperimentTPMType> E_tpmTypeList= new ArrayList<DataDrivenExperimentTPMType>();		
		List<DataDrivenExperimentTPMType> tpmTypeList= new ArrayList<DataDrivenExperimentTPMType>();
		
		if (tpmType!=null){
			
			if (geneTypeList.size()==1 && geneTypeList.contains(DataDrivenExperimentGeneType.NONEXPRESSING_PROTEINCODING_GENES)){
				NE_tpmTypeList.add(tpmType);
			}else if (geneTypeList.size()==1 && geneTypeList.contains(DataDrivenExperimentGeneType.EXPRESSING_PROTEINCODING_GENES)){
				E_tpmTypeList.add(tpmType);
			}
			
			distinguisingFileName = distinguisingFileName  + "_" + tpmType.convertEnumtoString();
		
		}else{
			//pool for them
			NE_tpmTypeList.add(DataDrivenExperimentTPMType.TOPUNKNOWN);
			
			E_tpmTypeList.add(DataDrivenExperimentTPMType.TOP5);
			E_tpmTypeList.add(DataDrivenExperimentTPMType.TOP20);
			
			if (tpmTypeTag==1){
				distinguisingFileName = distinguisingFileName  + "_" + "TopType";
			}
			
		}
		/**************************************************************************************/

		/**************************************************************************************/
		//Set 5 considered associationMeasureType
		List<AssociationMeasureType> associationMeasureTypeList= new ArrayList<AssociationMeasureType>();
		
		if (measureType!=null){			
			associationMeasureTypeList.add(measureType);	
			distinguisingFileName = distinguisingFileName + "_" + measureType.convertEnumtoShortString() ;

		}else{
			//pool for them
			associationMeasureTypeList.add(AssociationMeasureType.EXISTENCE_OF_OVERLAP);
			associationMeasureTypeList.add(AssociationMeasureType.NUMBER_OF_OVERLAPPING_BASES);
			
			if (measureTypeTag==1){
				distinguisingFileName = distinguisingFileName + "_" + "MeasureType";
			}

		}
		/**************************************************************************************/

		/**************************************************************************************/
		//Set 6 considered isochoreFamilyMode
		List<IsochoreFamilyMode> isochoreFamilyModeList= new ArrayList<IsochoreFamilyMode>();
		
		if (isochoreFamilyMode!=null){
			isochoreFamilyModeList.add(isochoreFamilyMode);
			distinguisingFileName = distinguisingFileName + "_" + isochoreFamilyMode.convertEnumtoShortString();

		}else{
			//pool for them
			isochoreFamilyModeList.add(IsochoreFamilyMode.DO_USE_ISOCHORE_FAMILY);
			isochoreFamilyModeList.add(IsochoreFamilyMode.DO_NOT_USE_ISOCHORE_FAMILY);
			
			if (isochoreFamilyModeTag==1){
				distinguisingFileName = distinguisingFileName + "_" + "IsochoreFamilyMode";
			}
		}
		/**************************************************************************************/
		
		/**************************************************************************************/
		//Set 7 considered generateRandomDataMode
		List<GenerateRandomDataMode> generateRandomDataModeList= new ArrayList<GenerateRandomDataMode>();
		
		if (generateRandomDataMode!=null){
			generateRandomDataModeList.add(generateRandomDataMode);
			distinguisingFileName = distinguisingFileName + "_" + generateRandomDataMode.convertEnumtoShortString();

		}else{
			//pool for them
			generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITH_GC_CONTENT);
			generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITH_MAPPABILITY);
			generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITH_MAPPABILITY_AND_GC_CONTENT);
			generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITHOUT_MAPPABILITY_AND_GC_CONTENT);
			
			if (generateRandomDataModeTag==1){
				distinguisingFileName = distinguisingFileName + "_" + "GenerateRandomDataMode";
			}
		}
		/**************************************************************************************/

		try {
			fileWriter_ROCCurve = FileOperations.createFileWriter(mainDirectory + System.getProperty("file.separator") + toolType.convertEnumtoString() + "_ROC_Curve_Data" + System.getProperty("file.separator") + toolType.convertEnumtoString() + "_ROC_Curve_Data_" +  distinguisingFileName + ".txt");
			bufferedWriter_ROCCurve = new BufferedWriter(fileWriter_ROCCurve);
						
			//Header line ROC Curve
			bufferedWriter_ROCCurve.write("D" + "\t" + "D.str" + "\t" + "M"  + "\t" + toolType.convertEnumtoString() + "Parameter" + System.getProperty("line.separator")); 	
							
			for(Iterator<DataDrivenExperimentCellLineType> cellLineItr = cellLineList.iterator();cellLineItr.hasNext();) {
				
				cellLine = cellLineItr.next();
				
				//Initialize
				activatorElementList.clear();
				repressorElementList.clear();
				fillWithDataDrivenExperimentElementNameTypesIncludingAmbigiousElements(cellLine,activatorElementList,repressorElementList);

			
				for(Iterator<DataDrivenExperimentGeneType> geneTypeItr = geneTypeList.iterator(); geneTypeItr.hasNext();){
					
					geneType = geneTypeItr.next();
					
					if (geneType.isNonExpressingProteinCodingGenes()){
						
						dnaseExclusionTypeList = NE_DnaseExclusionTypeList;	
						tpmTypeList = NE_tpmTypeList;
						
					}else if (geneType.isExpressingProteinCodingGenes()){	
						
						dnaseExclusionTypeList = E_DnaseExclusionTypeList;
						tpmTypeList = E_tpmTypeList;
					}
					
					
					for(Iterator<DataDrivenExperimentTPMType> tpmTypeItr = tpmTypeList.iterator();tpmTypeItr.hasNext();){
						
						tpmType = tpmTypeItr.next();
						
						for(Iterator<DataDrivenExperimentDnaseOverlapExclusionType> dnaseExclusionTypeItr = dnaseExclusionTypeList.iterator(); dnaseExclusionTypeItr.hasNext();){
							
							exclusionType = dnaseExclusionTypeItr.next();											
							
							for(Iterator<AssociationMeasureType> measureTypeItr = associationMeasureTypeList.iterator();measureTypeItr.hasNext();){
								
								measureType = measureTypeItr.next();
								
								
								switch(toolType){
								
									case GLANET:
										/*******************************************************************************/
										/*******************************GLANET starts***********************************/
										/*******************************************************************************/
										
										//If you give one specific isochoreFamily there will be only one isochoreFamily in the isochoreFamilyModeList
										for(Iterator<IsochoreFamilyMode> isochoreFamilyModeItr =  isochoreFamilyModeList.iterator();isochoreFamilyModeItr.hasNext();) {
											
											isochoreFamilyMode = isochoreFamilyModeItr.next();
											
											for(Iterator<GenerateRandomDataMode> generateRandomDataModeItr = generateRandomDataModeList.iterator(); generateRandomDataModeItr.hasNext();){
												
												generateRandomDataMode =generateRandomDataModeItr.next();
												
												tag = createTag(toolType,
																cellLine,cellLineTag,
																geneType,geneTypeTag,
																tpmType,tpmTypeTag,
																exclusionType,exclusionTypeTag,
																measureType,measureTypeTag,
																isochoreFamilyMode,isochoreFamilyModeTag,
																generateRandomDataMode,generateRandomDataModeTag);
												
												//Here we read isochore specific runDirectory
												runDirectory= "Output" + System.getProperty("file.separator") + cellLine + "_" + geneType.convertEnumtoString() + "_" + tpmType.convertEnumtoString() + "_" + exclusionType.convertEnumtoString() + "_" + generateRandomDataMode.convertEnumtoShortString() + "_" + isochoreFamilyMode.convertEnumtoShortString() + "_" + measureType.convertEnumtoShortString() + "Run";
												
												//We use empirical p-Value
												prepareTabDelimitedDataFileForGLANETROCCurveAndPRCurve(
														mainDirectory, 
														runDirectory, 
														numberofRuns, 
														geneType, 
														tag, 
														activatorElementList, 
														repressorElementList,
														bufferedWriter_ROCCurve,
														element2NumberofMissingPValuesMap);								
											
											}//End of for each generateRandomDataMode														
											
										}//End of each isochoreFamilyMode
										/*******************************************************************************/
										/*******************************GLANET ends*************************************/
										/*******************************************************************************/									
										break;
										
									case GAT:
										/*******************************************************************************/
										/*********************************GAT starts************************************/
										/*******************************************************************************/									
										//Initialization
										//For GAT I wrote wIF and woIF by myself in createTag method
										//Because GAT output filenames does not has wIF woIF in their names.
										
										//If isochoreFamilyMode is wIF collect only wGC(EOO) and wGCM(NOOB) results
										//If isochoreFamilyMode is woIF collect woGCM results (same for EOO and NOOB)
										//If thereis no isochoreFamilyMode set then collect all the results, simply pool them
										isochoreFamilyModeTag=0;  
										generateRandomDataModeList.clear();
										
										if (isochoreFamilyMode.useIsochoreFamily()){
											generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITH_GC_CONTENT);											
										}else if (isochoreFamilyMode.doNotUseIsochoreFamily()){
											generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITHOUT_MAPPABILITY_AND_GC_CONTENT);
										}else{
											//pool the results
											generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITH_GC_CONTENT);
											generateRandomDataModeList.add(GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITHOUT_MAPPABILITY_AND_GC_CONTENT);											
										}
										
										
										//GAT in fact only achieves wIF and woIF
										//For wIF I have named the files with wGC (EOO) and wGCM (NOOB)									
										//For woIF I have named the files with woGCM
										
										for(Iterator<GenerateRandomDataMode> generateRandomDataModeItr = generateRandomDataModeList.iterator(); generateRandomDataModeItr.hasNext();){
											
											generateRandomDataMode =generateRandomDataModeItr.next();
											
											tag = createTag(toolType,
															cellLine,cellLineTag,
															geneType,geneTypeTag,
															tpmType,tpmTypeTag,
															exclusionType,exclusionTypeTag,
															measureType,measureTypeTag,
															isochoreFamilyMode,isochoreFamilyModeTag,
															generateRandomDataMode,generateRandomDataModeTag);
											
											//GAT DDE Output EOO uses wGC and woGCM in filenames for wGC and woGCM, respectively.
											//GAT DDE Output NOOB uses wGCM and woGCM in filenames for wGC and woGCM, respectively.																				
											if (measureType.isAssociationMeasureNumberOfOverlappingBases() && generateRandomDataMode.isGenerateRandomDataModeWithGC()){
												runDirectory= "Output" + System.getProperty("file.separator") + toolType.convertEnumtoString() + "_" +  cellLine + "_" + geneType.convertEnumtoString() + "_" + tpmType.convertEnumtoString() + "_" + exclusionType.convertEnumtoString() + "_" + GenerateRandomDataMode.GENERATE_RANDOM_DATA_WITH_MAPPABILITY_AND_GC_CONTENT.convertEnumtoShortString() + "_" + measureType.convertEnumtoShortString() + "_" + Commons.DDE_RUN;
												
											}else{
												runDirectory= "Output" + System.getProperty("file.separator") + toolType.convertEnumtoString() + "_" +  cellLine + "_" + geneType.convertEnumtoString() + "_" + tpmType.convertEnumtoString() + "_" + exclusionType.convertEnumtoString() + "_" + generateRandomDataMode.convertEnumtoShortString() + "_" + measureType.convertEnumtoShortString() + "_" + Commons.DDE_RUN;
							
											}
											
											//We use empirical p-value
											prepareTabDelimitedDataFileForGATROCCurve(
													mainDirectory, 
													runDirectory, 
													numberofRuns, 
													geneType, 
													tag, 
													activatorElementList, 
													repressorElementList,
													bufferedWriter_ROCCurve);								
										
										}//End of for each generateRandomDataMode											
										/*******************************************************************************/
										/*********************************GAT ends**************************************/
										/*******************************************************************************/
										break;
										
									default:
										break;
								
								}//End of switch

							}//End of each associationMeasureType							
							
						}//End of for each dnaseExclusionType
						
					}//End of for each tpmType									
									
				}//End of for each geneType
				
			}//End of for each cellLine
		
			
			//It was for debug purposes
			//Write Information
			//writeInformation(element2NumberofMissingPValuesMap,bufferedWriter);
		
			//Close
			bufferedWriter_ROCCurve.close();
			
		}catch (IOException e) {
			e.printStackTrace();
		}
		
	}
	
	public static void main(String[] args) {
		
		//ROC curve data is also used for Precision Recall curve data
				
		//ToolType
		ToolType toolType = ToolType.convertStringtoEnum(args[0]);
						
		//MainDirectory excluding Output directory
		//Main directory must be the parent of Output Directory
		String mainDirectory=args[1];
		
		//numberofRuns
		int numberofRuns = Integer.parseInt(args[2]);
		
		//cellLine
		DataDrivenExperimentCellLineType cellLine = DataDrivenExperimentCellLineType.convertStringtoEnum(args[3]);
		int cellLineTag = Integer.parseInt(args[4]);
		
		//geneType 
		//NonExpressed Genes
		//Expressed Genes
		DataDrivenExperimentGeneType geneType = DataDrivenExperimentGeneType.convertStringtoEnum(args[5]);
		int geneTypeTag = Integer.parseInt(args[6]);
				
		//dnaseExclusionType 
		//CompletelyDiscard
		//TakeTheLongest
		//NoDiscard
		DataDrivenExperimentDnaseOverlapExclusionType exclusionType = DataDrivenExperimentDnaseOverlapExclusionType.convertStringtoEnum(args[7]);
		int exclusionTypeTag = Integer.parseInt(args[8]);
		
		//TopUnknown
		//Top5
		//Top20
		DataDrivenExperimentTPMType tpmType = DataDrivenExperimentTPMType.convertStringtoEnum(args[9]);
		int tpmTypeTag = Integer.parseInt(args[10]);
		
		//EOO
		//NOOB
		AssociationMeasureType measureType = AssociationMeasureType.convertStringtoEnum(args[11]);
		int measureTypeTag = Integer.parseInt(args[12]);
		
		//isochoreMode
		//wIF
		//woIF
		IsochoreFamilyMode isochoreFamilyMode = IsochoreFamilyMode.convertStringtoEnum(args[13]);
		int isochoreFamilyModeTag = Integer.parseInt(args[14]);

		//wGC
		//wM
		//wGCM
		//woGCM
		GenerateRandomDataMode generateRandomDataMode = GenerateRandomDataMode.convertStringtoEnum(args[15]);
		int generateRandomDataModeTag = Integer.parseInt(args[16]);
	
//		/**************************************************************************************/
//		String trubaMainDirectory = 	System.getProperty("file.separator") + "truba" + 
//								System.getProperty("file.separator") + "home" +
//								System.getProperty("file.separator") + "botlu" + 
//								System.getProperty("file.separator") + "GLANET" + 
//								System.getProperty("file.separator");
//		/**************************************************************************************/
		
//		/**************************************************************************************/
//		String debugMainDirectory = 	"C:" + System.getProperty("file.separator") + "Users" + 
//				System.getProperty("file.separator") + "Burçak" +
//				System.getProperty("file.separator") + "Google Drive" + 
//				System.getProperty("file.separator") + "GLANET_Bioinformatics_2ndSubmission" + 
//				System.getProperty("file.separator") + "ROCCurves" + System.getProperty("file.separator");
//		/**************************************************************************************/
		
		prepareDataFileForROCCurves(
				toolType,
				mainDirectory,
				numberofRuns,
				cellLine,
				cellLineTag,
				geneType,
				geneTypeTag,
				exclusionType,
				exclusionTypeTag,
				tpmType,
				tpmTypeTag,
				measureType,
				measureTypeTag,
				isochoreFamilyMode,
				isochoreFamilyModeTag,
				generateRandomDataMode,
				generateRandomDataModeTag);
	
	}

}
